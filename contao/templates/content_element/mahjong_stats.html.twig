{% extends '@Contao/content_element/_base.html.twig' %}
{% trans_default_domain 'contao_default' %}

{% block content %}
    <div class="options">
        <label for="offset">{{ 'mjs.offset'|trans }}</label>
        <input x-data x-model.number="$store.graphs.numShow" type="number" step="10" min="10" name="offset" id="offset">
        <label for="recent">Recent (small)</label>
        <input x-data x-model.number="$store.graphs.numRecentSmall" type="number" min="1" name="recent" id="offset">
        <label for="recent2">Recent (big)</label>
        <input x-data x-model.number="$store.graphs.numRecentBig" type="number" step="10" min="10" name="recent2" id="offset">
    </div>
    <div x-data="statsView">
    <div id="section">
        <h3 id="anchor">Current goals</h3>
        <canvas id="chartjs"></canvas>
    </div>
    <div id="section-rank">
        <h3 id="anchor-rank">Rank</h3>
        <canvas id="chartjs-rank"></canvas>
        <div id="streaks-no-first" style="margin-top: 1rem;">
            <h4>{{ 'tl_patrickj_mjs.streakNoFirst.0'|trans }}</h4>
            <div>
                <strong>{{ 'tl_patrickj_mjs.streakLongest.0'|trans }}:</strong>
                <span x-text="noFirst.maxText"></span>
            </div>
            <template x-if="noFirst.topGroups.length">
                <ul style="margin: .25rem 0 0 .75rem;">
                    <template x-for="group in noFirst.topGroups" :key="'nf-'+group.len">
                        <li>
                            <strong x-text="group.len.toLocaleString()"></strong>
                            <ul style="margin: .25rem 0 0 .75rem;">
                                <template x-for="rng in group.ranges" :key="'nf_rng_'+rng.start+'_'+rng.end">
                                    <li x-text="rangeLabel(rng)"></li>
                                </template>
                            </ul>
                        </li>
                    </template>
                </ul>
            </template>
        </div>
        <div id="streaks-no-fourth" style="margin-top: 1rem;">
            <h4>{{ 'tl_patrickj_mjs.streakNoFourth.0'|trans }}</h4>
            <div>
                <strong>{{ 'tl_patrickj_mjs.streakLongest.0'|trans }}:</strong>
                <span x-text="noFourth.maxText"></span>
            </div>
            <template x-if="noFourth.topGroups.length">
                <ul style="margin: .25rem 0 0 .75rem;">
                    <template x-for="group in noFourth.topGroups" :key="'n4-'+group.len">
                        <li>
                            <strong x-text="group.len.toLocaleString()"></strong>
                            <ul style="margin: .25rem 0 0 .75rem;">
                                <template x-for="rng in group.ranges" :key="'n4_rng_'+rng.start+'_'+rng.end">
                                    <li x-text="rangeLabel(rng)"></li>
                                </template>
                            </ul>
                        </li>
                    </template>
                </ul>
            </template>
        </div>
        <div id="streaks-consecutive" style="margin-top: 1rem;">
            <h4>{{ 'tl_patrickj_mjs.streakConsecutive.0'|trans }}</h4>
            <ul style="margin: .25rem 0 0 .75rem;">
                <template x-for="row in consecutivePlace.top" :key="'cp-'+row.place">
                    <li>
                        <div>
                            <strong x-text="row.placeLabel"></strong>:
                            <span x-text="row.maxText"></span>
                        </div>
                        <ul style="margin: .25rem 0 0 .75rem;">
                            <template x-for="rng in row.ranges" :key="'cp_rng_'+rng.start+'_'+rng.end">
                                <li x-text="rangeLabel(rng)"></li>
                            </template>
                        </ul>
                    </li>
                </template>
            </ul>
        </div>
    </div>
    <div id="section-points">
        <h3 id="anchor-points">Points</h3>
        <canvas id="chartjs-points"></canvas>
        <div id="high-scores" style="margin-top: 1rem;">
            <h4>{{ 'tl_patrickj_mjs.highScores.0'|trans }}</h4>
            <ul style="margin: .25rem 0 0 .75rem;">
                <li>
                    <div>
                        <strong>{{ 'tl_patrickj_mjs.highScoreEver.0'|trans }}:</strong>
                        <span x-text="formatInt(highScores.ever.value)"></span>
                    </div>
                    <ul style="margin: .25rem 0 0 .75rem;">
                        <template x-for="tp in highScores.ever.tps" :key="'hse-'+tp">
                            <li x-text="tp"></li>
                        </template>
                    </ul>
                    <ul style="margin: .25rem 0 0 .75rem;">
                        <template x-for="grp in highScores.ever.topGroups" :key="'hset-'+grp.value">
                            <li>
                                <strong x-text="formatInt(grp.value)"></strong>
                                <ul style="margin: .25rem 0 0 .75rem;">
                                    <template x-for="tp in grp.tps" :key="'hset_tp_'+tp">
                                        <li x-text="tp"></li>
                                    </template>
                                </ul>
                            </li>
                        </template>
                    </ul>
                </li>
                <li>
                    <div>
                        <strong>{{ 'tl_patrickj_mjs.highScoreRecentSmall.0'|trans }}:</strong>
                        <span x-text="formatInt(highScores.small.value)"></span>
                    </div>
                    <ul style="margin: .25rem 0 0 .75rem;">
                        <template x-for="tp in highScores.small.tps" :key="'hss-'+tp">
                            <li x-text="tp"></li>
                        </template>
                    </ul>
                    <ul style="margin: .25rem 0 0 .75rem;">
                        <template x-for="grp in highScores.small.topGroups" :key="'hsst-'+grp.value">
                            <li>
                                <strong x-text="formatInt(grp.value)"></strong>
                                <ul style="margin: .25rem 0 0 .75rem;">
                                    <template x-for="tp in grp.tps" :key="'hsst_tp_'+tp">
                                        <li x-text="tp"></li>
                                    </template>
                                </ul>
                            </li>
                        </template>
                    </ul>
                </li>
                <li>
                    <div>
                        <strong>{{ 'tl_patrickj_mjs.highScoreRecentBig.0'|trans }}:</strong>
                        <span x-text="formatInt(highScores.big.value)"></span>
                    </div>
                    <ul style="margin: .25rem 0 0 .75rem;">
                        <template x-for="tp in highScores.big.tps" :key="'hsb-'+tp">
                            <li x-text="tp"></li>
                        </template>
                    </ul>
                    <ul style="margin: .25rem 0 0 .75rem;">
                        <template x-for="grp in highScores.big.topGroups" :key="'hsbt-'+grp.value">
                            <li>
                                <strong x-text="formatInt(grp.value)"></strong>
                                <ul style="margin: .25rem 0 0 .75rem;">
                                    <template x-for="tp in grp.tps" :key="'hsbt_tp_'+tp">
                                        <li x-text="tp"></li>
                                    </template>
                                </ul>
                            </li>
                        </template>
                    </ul>
                </li>
            </ul>
        </div>
        <div id="low-scores" style="margin-top: 1rem;">
            <h4>{{ 'tl_patrickj_mjs.lowScores.0'|trans }}</h4>
            <ul style="margin: .25rem 0 0 .75rem;">
                <li>
                    <div>
                        <strong>{{ 'tl_patrickj_mjs.lowScoreEver.0'|trans }}:</strong>
                        <span x-text="formatInt(lowScores.ever.value)"></span>
                    </div>
                    <ul style="margin: .25rem 0 0 .75rem;">
                        <template x-for="tp in lowScores.ever.tps" :key="'lse-'+tp">
                            <li x-text="tp"></li>
                        </template>
                    </ul>
                    <ul style="margin: .25rem 0 0 .75rem;">
                        <template x-for="grp in lowScores.ever.topGroups" :key="'lset-'+grp.value">
                            <li>
                                <strong x-text="formatInt(grp.value)"></strong>
                                <ul style="margin: .25rem 0 0 .75rem;">
                                    <template x-for="tp in grp.tps" :key="'lset_tp_'+tp">
                                        <li x-text="tp"></li>
                                    </template>
                                </ul>
                            </li>
                        </template>
                    </ul>
                </li>
                <li>
                    <div>
                        <strong>{{ 'tl_patrickj_mjs.lowScoreRecentSmall.0'|trans }}:</strong>
                        <span x-text="formatInt(lowScores.small.value)"></span>
                    </div>
                    <ul style="margin: .25rem 0 0 .75rem;">
                        <template x-for="tp in lowScores.small.tps" :key="'lss-'+tp">
                            <li x-text="tp"></li>
                        </template>
                    </ul>
                    <ul style="margin: .25rem 0 0 .75rem;">
                        <template x-for="grp in lowScores.small.topGroups" :key="'lsst-'+grp.value">
                            <li>
                                <strong x-text="formatInt(grp.value)"></strong>
                                <ul style="margin: .25rem 0 0 .75rem;">
                                    <template x-for="tp in grp.tps" :key="'lsst_tp_'+tp">
                                        <li x-text="tp"></li>
                                    </template>
                                </ul>
                            </li>
                        </template>
                    </ul>
                </li>
                <li>
                    <div>
                        <strong>{{ 'tl_patrickj_mjs.lowScoreRecentBig.0'|trans }}:</strong>
                        <span x-text="formatInt(lowScores.big.value)"></span>
                    </div>
                    <ul style="margin: .25rem 0 0 .75rem;">
                        <template x-for="tp in lowScores.big.tps" :key="'lsb-'+tp">
                            <li x-text="tp"></li>
                        </template>
                    </ul>
                    <ul style="margin: .25rem 0 0 .75rem;">
                        <template x-for="grp in lowScores.big.topGroups" :key="'lsbt-'+grp.value">
                            <li>
                                <strong x-text="formatInt(grp.value)"></strong>
                                <ul style="margin: .25rem 0 0 .75rem;">
                                    <template x-for="tp in grp.tps" :key="'lsbt_tp_'+tp">
                                        <li x-text="tp"></li>
                                    </template>
                                </ul>
                            </li>
                        </template>
                    </ul>
                </li>
            </ul>
        </div>
        <div id="high-avg-scores" style="margin-top: 1rem;">
            <h4>{{ 'tl_patrickj_mjs.highAvgScores.0'|trans }}</h4>
            <ul style="margin: .25rem 0 0 .75rem;">
                <li>
                    <div>
                        <strong>{{ 'tl_patrickj_mjs.highAvgScoreEver.0'|trans }}:</strong>
                        <span x-text="formatAvg(highAvgScores.ever.value)"></span>
                    </div>
                    <ul style="margin: .25rem 0 0 .75rem;">
                        <template x-for="tp in highAvgScores.ever.tps" :key="'hae-'+tp">
                            <li x-text="tp"></li>
                        </template>
                    </ul>
                </li>
                <li>
                    <div>
                        <strong>{{ 'tl_patrickj_mjs.highAvgScoreRecentSmall.0'|trans }}:</strong>
                        <span x-text="formatAvg(highAvgScores.small.value)"></span>
                    </div>
                    <ul style="margin: .25rem 0 0 .75rem;">
                        <template x-for="tp in highAvgScores.small.tps" :key="'has-'+tp">
                            <li x-text="tp"></li>
                        </template>
                    </ul>
                </li>
                <li>
                    <div>
                        <strong>{{ 'tl_patrickj_mjs.highAvgScoreRecentBig.0'|trans }}:</strong>
                        <span x-text="formatAvg(highAvgScores.big.value)"></span>
                    </div>
                    <ul style="margin: .25rem 0 0 .75rem;">
                        <template x-for="tp in highAvgScores.big.tps" :key="'hab-'+tp">
                            <li x-text="tp"></li>
                        </template>
                    </ul>
                </li>
            </ul>
        </div>
        <div id="low-avg-scores" style="margin-top: 1rem;">
            <h4>{{ 'tl_patrickj_mjs.lowAvgScores.0'|trans }}</h4>
            <ul style="margin: .25rem 0 0 .75rem;">
                <li>
                    <div>
                        <strong>{{ 'tl_patrickj_mjs.lowAvgScoreEver.0'|trans }}:</strong>
                        <span x-text="formatAvg(lowAvgScores.ever.value)"></span>
                    </div>
                    <ul style="margin: .25rem 0 0 .75rem;">
                        <template x-for="tp in lowAvgScores.ever.tps" :key="'lae-'+tp">
                            <li x-text="tp"></li>
                        </template>
                    </ul>
                </li>
                <li>
                    <div>
                        <strong>{{ 'tl_patrickj_mjs.lowAvgScoreRecentSmall.0'|trans }}:</strong>
                        <span x-text="formatAvg(lowAvgScores.small.value)"></span>
                    </div>
                    <ul style="margin: .25rem 0 0 .75rem;">
                        <template x-for="tp in lowAvgScores.small.tps" :key="'las-'+tp">
                            <li x-text="tp"></li>
                        </template>
                    </ul>
                </li>
                <li>
                    <div>
                        <strong>{{ 'tl_patrickj_mjs.lowAvgScoreRecentBig.0'|trans }}:</strong>
                        <span x-text="formatAvg(lowAvgScores.big.value)"></span>
                    </div>
                    <ul style="margin: .25rem 0 0 .75rem;">
                        <template x-for="tp in lowAvgScores.big.tps" :key="'lab-'+tp">
                            <li x-text="tp"></li>
                        </template>
                    </ul>
                </li>
            </ul>
        </div>
    </div>
    <div id="section-places">
        <h3 id="anchor-places">Places</h3>
        <canvas id="chartjs-places"></canvas>
    </div>
    <div id="section-style">
        <h3 id="anchor-style">"Style"</h3>
        <canvas id="chartjs-style"></canvas>
    </div>
    <div id="section-mega">
        <h3 id="anchor-mega">Other</h3>
        <canvas id="chartjs-mega"></canvas>
    </div>
    </div>
{% endblock %}

{% block style %}
    <style>
        .mod_article.block {
            overflow: unset;
        }
        .options {
            position: sticky;
            top: 0;
            padding-top: 0.5rem;
            padding-bottom: 0.5rem;
            background: #fff;
        }
        [id^="section"] {
            scroll-snap-align: start;
        }
    </style>
{% endblock %}

{% block script %}
    <script src="/bundles/patrickjmjs/js/chart.umd.js" crossorigin="anonymous" referrerpolicy="no-referrer"></script>
    <script>
    document.documentElement.style.scrollSnapType = 'y mandatory';
    document.addEventListener('alpine:init', () => {
        // helper functions
        const averager = (baseArr, propName, length) => {
            let sum = 0;
            return baseArr.map((row, i, arr) => {
                sum += parseInt(row[propName]);
                if (length > 0) {
                    if (i < length - 1) return null;
                    if (i === length - 1) return sum / length;
                    sum -= parseInt(arr[i - length][propName]);
                }
                return sum / (length || (i + 1));
            })
        }
        const rater = (baseArr, propName, value, length) => {
            let count = 0;
            return baseArr.map((row, i, arr) => {
                if (typeof value === 'function') {
                    if (value(row[propName])) {
                        count++;
                    }
                } else {
                    if (row[propName] === value)  {
                        count++
                    }
                }
                if (length > 0) {
                    if (i < length - 1) return null;
                    if (i === length - 1) return Math.round(count / length * 10000) / 100;
                    if (typeof value === 'function') {
                        if (value(arr[i - length][propName])) {
                            count--;
                        }
                    } else {
                        if (arr[i - length][propName] === value) {
                            count--
                        }
                    }
                }
                return Math.round(count / (length || (i + 1)) * 10000) / 100;
            })
        }
        const computeStreaks = (arr, predicate) => {
            let max = 0;
            let cur = 0;
            let startIdx = null;
            const segments = [];
            for (let i = 0; i < arr.length; i++) {
                const ok = predicate(arr[i]);
                if (ok) {
                    if (cur === 0) startIdx = i;
                    cur++;
                } else {
                    if (cur > 0) {
                        segments.push({ len: cur, start: startIdx, end: i - 1 });
                        if (cur > max) max = cur;
                        cur = 0;
                        startIdx = null;
                    }
                }
            }
            if (cur > 0) {
                segments.push({ len: cur, start: startIdx, end: arr.length - 1 });
                if (cur > max) max = cur;
            }
            const longest = segments.filter(s => s.len === max);
            return { max, segments, longest };
        }
        const topStreakGroups = (segments, topN = 3) => {
            // Group segments by their length, then take the top N unique lengths (desc)
            const byLen = segments.reduce((acc, s) => {
                (acc[s.len] ||= []).push(s);
                return acc;
            }, {});
            const lengths = Object.keys(byLen).map(Number).sort((a, b) => b - a).slice(0, topN);
            // Within each length, sort by earliest occurrence (start asc)
            return lengths.map(len => ({
                len,
                ranges: byLen[len].sort((a, b) => a.start - b.start)
            }));
        }
        const computeMaxInRange = (arr, accessor, startIdx = 0, endIdx = arr.length - 1) => {
            if (!arr || !arr.length) return { max: null, indices: [] };
            startIdx = Math.max(0, startIdx);
            endIdx = Math.min(arr.length - 1, endIdx);
            if (endIdx < startIdx) return { max: null, indices: [] };
            let max = null;
            const indices = [];
            for (let i = startIdx; i <= endIdx; i++) {
                const v = accessor(arr[i]);
                if (v === null || v === undefined || isNaN(v)) continue;
                if (max === null || v > max) {
                    max = v;
                    indices.length = 0;
                    indices.push(i);
                } else if (v === max) {
                    indices.push(i);
                }
            }
            return { max, indices };
        }
        // Compute max and indices for a simple numeric series (numbers or nulls)
        const computeMaxInSeries = (series, startIdx = 0, endIdx = (series?.length || 0) - 1) => {
            if (!Array.isArray(series) || !series.length) return { max: null, indices: [] };
            startIdx = Math.max(0, startIdx);
            endIdx = Math.min(series.length - 1, endIdx);
            if (endIdx < startIdx) return { max: null, indices: [] };
            let max = null;
            const indices = [];
            for (let i = startIdx; i <= endIdx; i++) {
                const v = series[i];
                if (v === null || v === undefined || isNaN(v)) continue;
                if (max === null || v > max) {
                    max = v;
                    indices.length = 0;
                    indices.push(i);
                } else if (v === max) {
                    indices.push(i);
                }
            }
            return { max, indices };
        }
        const computeMinInRange = (arr, accessor, startIdx = 0, endIdx = arr.length - 1) => {
            if (!arr || !arr.length) return { min: null, indices: [] };
            startIdx = Math.max(0, startIdx);
            endIdx = Math.min(arr.length - 1, endIdx);
            if (endIdx < startIdx) return { min: null, indices: [] };
            let min = null;
            const indices = [];
            for (let i = startIdx; i <= endIdx; i++) {
                const v = accessor(arr[i]);
                if (v === null || v === undefined || isNaN(v)) continue;
                if (min === null || v < min) {
                    min = v;
                    indices.length = 0;
                    indices.push(i);
                } else if (v === min) {
                    indices.push(i);
                }
            }
            return { min, indices };
        }
        const computeMinInSeries = (series, startIdx = 0, endIdx = (series?.length || 0) - 1) => {
            if (!Array.isArray(series) || !series.length) return { min: null, indices: [] };
            startIdx = Math.max(0, startIdx);
            endIdx = Math.min(series.length - 1, endIdx);
            if (endIdx < startIdx) return { min: null, indices: [] };
            let min = null;
            const indices = [];
            for (let i = startIdx; i <= endIdx; i++) {
                const v = series[i];
                if (v === null || v === undefined || isNaN(v)) continue;
                if (min === null || v < min) {
                    min = v;
                    indices.length = 0;
                    indices.push(i);
                } else if (v === min) {
                    indices.push(i);
                }
            }
            return { min, indices };
        }
        const topValueGroupsInRange = (arr, accessor, startIdx, endIdx, order = 'desc', topN = 3) => {
            if (!arr || !arr.length) return [];
            startIdx = Math.max(0, startIdx);
            endIdx = Math.min(arr.length - 1, endIdx);
            const map = new Map(); // value -> indices[]
            for (let i = startIdx; i <= endIdx; i++) {
                const v = accessor(arr[i]);
                if (v === null || v === undefined || isNaN(v)) continue;
                const key = v;
                if (!map.has(key)) map.set(key, []);
                map.get(key).push(i);
            }
            const values = Array.from(map.keys()).sort((a, b) => order === 'asc' ? a - b : b - a).slice(0, topN);
            return values.map(value => ({ value, indices: map.get(value).sort((a, b) => a - b) }));
        }
        // Alpine.js data-driven UI for stats panels
        Alpine.data('statsView', () => ({
            // formatters
            formatInt(n) { return (typeof n === 'number' && !isNaN(n)) ? n.toLocaleString() : '-'; },
            formatAvg(n) { return (typeof n === 'number' && !isNaN(n)) ? n.toLocaleString(undefined, { minimumFractionDigits: 2, maximumFractionDigits: 2 }) : '-'; },
            rangeLabel(rng) {
                const start = rawData[rng.start]?.totalPlayed;
                const end = rawData[rng.end]?.totalPlayed;
                if (start == null || end == null) return '';
                return start === end ? `${start}` : `${start} - ${end}`;
            },
            // streaks: no first and no fourth, plus consecutive by place
            get noFirst() {
                const segments = computeStreaks(rawData, r => parseInt(r.recentResult) !== 1).segments;
                const groups = topStreakGroups(segments, 3);
                const max = groups.length ? groups[0].len : 0;
                return {
                    max,
                    maxText: max ? `${max.toLocaleString()} {{ 'tl_patrickj_mjs.games.0'|trans }}` : '-',
                    topGroups: groups,
                };
            },
            get noFourth() {
                const segments = computeStreaks(rawData, r => parseInt(r.recentResult) !== 4).segments;
                const groups = topStreakGroups(segments, 3);
                const max = groups.length ? groups[0].len : 0;
                return {
                    max,
                    maxText: max ? `${max.toLocaleString()} {{ 'tl_patrickj_mjs.games.0'|trans }}` : '-',
                    topGroups: groups,
                };
            },
            get consecutivePlace() {
                const out = [];
                for (let p = 1; p <= 4; p++) {
                    const segs = computeStreaks(rawData, r => parseInt(r.recentResult) === p).segments;
                    const groups = topStreakGroups(segs, 1);
                    const max = groups.length ? groups[0].len : 0;
                    out.push({
                        place: p,
                        placeLabel: (p === 1 ? '{{ 'tl_patrickj_mjs.rateFirst.0'|trans }}' : p === 2 ? '{{ 'tl_patrickj_mjs.rateSecond.0'|trans }}' : p === 3 ? '{{ 'tl_patrickj_mjs.rateThird.0'|trans }}' : '{{ 'tl_patrickj_mjs.rateFourth.0'|trans }}'),
                        max,
                        maxText: max ? `${max.toLocaleString()} {{ 'tl_patrickj_mjs.games.0'|trans }}` : '-',
                        ranges: groups.length ? groups[0].ranges : [],
                    });
                }
                return { top: out };
            },
            // High/Low match scores with groups
            get highScores() {
                const accessor = row => parseInt(row.recentScore);
                const nSmall = Math.max(1, parseInt(Alpine.store('graphs')?.numRecentSmall || 0));
                const nBig = Math.max(1, parseInt(Alpine.store('graphs')?.numRecentBig || 0));
                const startSmall = Math.max(0, rawData.length - nSmall);
                const startBig = Math.max(0, rawData.length - nBig);
                const pack = (res) => ({
                    value: res.max,
                    tps: (res.indices || []).map(i => rawData[i]?.totalPlayed).filter(v => v != null),
                });
                const packGroups = (groups) => groups.map(g => ({ value: g.value, tps: g.indices.map(i => rawData[i]?.totalPlayed).filter(v => v != null) }));
                const everRes = computeMaxInRange(rawData, accessor, 0, rawData.length - 1);
                const smallRes = computeMaxInRange(rawData, accessor, startSmall, rawData.length - 1);
                const bigRes = computeMaxInRange(rawData, accessor, startBig, rawData.length - 1);
                return {
                    ever: { ...pack(everRes), topGroups: packGroups(topValueGroupsInRange(rawData, accessor, 0, rawData.length - 1, 'desc', 3)) },
                    small: { ...pack(smallRes), topGroups: packGroups(topValueGroupsInRange(rawData, accessor, startSmall, rawData.length - 1, 'desc', 3)) },
                    big: { ...pack(bigRes), topGroups: packGroups(topValueGroupsInRange(rawData, accessor, startBig, rawData.length - 1, 'desc', 3)) },
                };
            },
            get lowScores() {
                const accessor = row => parseInt(row.recentScore);
                const nSmall = Math.max(1, parseInt(Alpine.store('graphs')?.numRecentSmall || 0));
                const nBig = Math.max(1, parseInt(Alpine.store('graphs')?.numRecentBig || 0));
                const startSmall = Math.max(0, rawData.length - nSmall);
                const startBig = Math.max(0, rawData.length - nBig);
                const pack = (res) => ({
                    value: res.min,
                    tps: (res.indices || []).map(i => rawData[i]?.totalPlayed).filter(v => v != null),
                });
                const packGroups = (groups) => groups.map(g => ({ value: g.value, tps: g.indices.map(i => rawData[i]?.totalPlayed).filter(v => v != null) }));
                const everRes = computeMinInRange(rawData, accessor, 0, rawData.length - 1);
                const smallRes = computeMinInRange(rawData, accessor, startSmall, rawData.length - 1);
                const bigRes = computeMinInRange(rawData, accessor, startBig, rawData.length - 1);
                return {
                    ever: { ...pack(everRes), topGroups: packGroups(topValueGroupsInRange(rawData, accessor, 0, rawData.length - 1, 'asc', 3)) },
                    small: { ...pack(smallRes), topGroups: packGroups(topValueGroupsInRange(rawData, accessor, startSmall, rawData.length - 1, 'asc', 3)) },
                    big: { ...pack(bigRes), topGroups: packGroups(topValueGroupsInRange(rawData, accessor, startBig, rawData.length - 1, 'asc', 3)) },
                };
            },
            // Average scores (use parsedData series) with skip rule
            get highAvgScores() {
                const seriesEver = parsedData['recentScore_avg'];
                const seriesSmall = parsedData['recentScore_avgSmall'];
                const seriesBig = parsedData['recentScore_avgBig'];
                const nSmall = Math.max(1, parseInt(Alpine.store('graphs')?.numRecentSmall || 0));
                const nBig = Math.max(1, parseInt(Alpine.store('graphs')?.numRecentBig || 0));
                const skipN = Math.max(0, Math.min(nSmall, nBig));
                const startSmall = Math.max(skipN, (seriesSmall?.length || 0) - nSmall);
                const startBig = Math.max(skipN, (seriesBig?.length || 0) - nBig);
                const everRes = computeMaxInSeries(seriesEver, skipN, (seriesEver?.length || 1) - 1);
                const smallRes = computeMaxInSeries(seriesSmall, startSmall, (seriesSmall?.length || 1) - 1);
                const bigRes = computeMaxInSeries(seriesBig, startBig, (seriesBig?.length || 1) - 1);
                const pack = (res) => ({ value: res.max, tps: (res.indices || []).map(i => rawData[i]?.totalPlayed).filter(v => v != null) });
                return { ever: pack(everRes), small: pack(smallRes), big: pack(bigRes) };
            },
            get lowAvgScores() {
                const seriesEver = parsedData['recentScore_avg'];
                const seriesSmall = parsedData['recentScore_avgSmall'];
                const seriesBig = parsedData['recentScore_avgBig'];
                const nSmall = Math.max(1, parseInt(Alpine.store('graphs')?.numRecentSmall || 0));
                const nBig = Math.max(1, parseInt(Alpine.store('graphs')?.numRecentBig || 0));
                const skipN = Math.max(0, Math.min(nSmall, nBig));
                const startSmall = Math.max(skipN, (seriesSmall?.length || 0) - nSmall);
                const startBig = Math.max(skipN, (seriesBig?.length || 0) - nBig);
                const everRes = computeMinInSeries(seriesEver, skipN, (seriesEver?.length || 1) - 1);
                const smallRes = computeMinInSeries(seriesSmall, startSmall, (seriesSmall?.length || 1) - 1);
                const bigRes = computeMinInSeries(seriesBig, startBig, (seriesBig?.length || 1) - 1);
                const pack = (res) => ({ value: res.min, tps: (res.indices || []).map(i => rawData[i]?.totalPlayed).filter(v => v != null) });
                return { ever: pack(everRes), small: pack(smallRes), big: pack(bigRes) };
            },
        }));
        const renderHighAvgScores = () => {
            try {
                const valEver = document.getElementById('highAvgScoreEverValue');
                const listEver = document.getElementById('highAvgScoreEverRanges');
                const valSmall = document.getElementById('highAvgScoreRecentSmallValue');
                const listSmall = document.getElementById('highAvgScoreRecentSmallRanges');
                const valBig = document.getElementById('highAvgScoreRecentBigValue');
                const listBig = document.getElementById('highAvgScoreRecentBigRanges');
                if (!(valEver && listEver && valSmall && listSmall && valBig && listBig)) return;
                const formatNum = n => typeof n === 'number' ? n.toLocaleString(undefined, { minimumFractionDigits: 2, maximumFractionDigits: 2 }) : '-';

                // Series sources: use parsedData rolling averages
                const seriesEver = parsedData['recentScore_avg']; // cumulative average
                const seriesSmall = parsedData['recentScore_avgSmall']; // rolling avg with window = numRecentSmall
                const seriesBig = parsedData['recentScore_avgBig']; // rolling avg with window = numRecentBig

                // Determine how many initial entries to ignore: min(numRecentSmall, numRecentBig)
                const smallN = Math.max(1, parseInt(Alpine.store('graphs')?.numRecentSmall || 0));
                const bigN = Math.max(1, parseInt(Alpine.store('graphs')?.numRecentBig || 0));
                const skipN = Math.max(0, Math.min(smallN, bigN));

                // Ever (search entire series after skipping first N entries)
                const ever = computeMaxInSeries(seriesEver, skipN, (seriesEver?.length || 1) - 1);
                valEver.textContent = formatNum(ever.max);
                listEver.innerHTML = '';
                ever.indices.forEach(i => {
                    const li = document.createElement('li');
                    const tp = rawData[i]?.totalPlayed;
                    if (tp !== undefined) li.textContent = `${tp}`;
                    listEver.appendChild(li);
                });

                // Recent windows: look at last N/M entries of the corresponding rolling-average series
                const startSmall = Math.max(skipN, (seriesSmall?.length || 0) - smallN);
                const startBig = Math.max(skipN, (seriesBig?.length || 0) - bigN);

                const recentSmall = computeMaxInSeries(seriesSmall, startSmall, (seriesSmall?.length || 1) - 1);
                valSmall.textContent = formatNum(recentSmall.max);
                listSmall.innerHTML = '';
                recentSmall.indices.forEach(i => {
                    const li = document.createElement('li');
                    const tp = rawData[i]?.totalPlayed;
                    if (tp !== undefined) li.textContent = `${tp}`;
                    listSmall.appendChild(li);
                });

                const recentBig = computeMaxInSeries(seriesBig, startBig, (seriesBig?.length || 1) - 1);
                valBig.textContent = formatNum(recentBig.max);
                listBig.innerHTML = '';
                recentBig.indices.forEach(i => {
                    const li = document.createElement('li');
                    const tp = rawData[i]?.totalPlayed;
                    if (tp !== undefined) li.textContent = `${tp}`;
                    listBig.appendChild(li);
                });
            } catch (e) {
                console.warn('Failed to render high average scores', e);
            }
        }
        const renderLowAvgScores = () => {
            try {
                const valEver = document.getElementById('lowAvgScoreEverValue');
                const listEver = document.getElementById('lowAvgScoreEverRanges');
                const valSmall = document.getElementById('lowAvgScoreRecentSmallValue');
                const listSmall = document.getElementById('lowAvgScoreRecentSmallRanges');
                const valBig = document.getElementById('lowAvgScoreRecentBigValue');
                const listBig = document.getElementById('lowAvgScoreRecentBigRanges');
                if (!(valEver && listEver && valSmall && listSmall && valBig && listBig)) return;
                const formatNum = n => typeof n === 'number' ? n.toLocaleString(undefined, { minimumFractionDigits: 2, maximumFractionDigits: 2 }) : '-';

                const seriesEver = parsedData['recentScore_avg'];
                const seriesSmall = parsedData['recentScore_avgSmall'];
                const seriesBig = parsedData['recentScore_avgBig'];

                const smallN = Math.max(1, parseInt(Alpine.store('graphs')?.numRecentSmall || 0));
                const bigN = Math.max(1, parseInt(Alpine.store('graphs')?.numRecentBig || 0));
                const skipN = Math.max(0, Math.min(smallN, bigN));

                const ever = computeMinInSeries(seriesEver, skipN, (seriesEver?.length || 1) - 1);
                valEver.textContent = formatNum(ever.min);
                listEver.innerHTML = '';
                ever.indices.forEach(i => {
                    const li = document.createElement('li');
                    const tp = rawData[i]?.totalPlayed;
                    if (tp !== undefined) li.textContent = `${tp}`;
                    listEver.appendChild(li);
                });

                const startSmall = Math.max(skipN, (seriesSmall?.length || 0) - smallN);
                const startBig = Math.max(skipN, (seriesBig?.length || 0) - bigN);

                const recentSmall = computeMinInSeries(seriesSmall, startSmall, (seriesSmall?.length || 1) - 1);
                valSmall.textContent = formatNum(recentSmall.min);
                listSmall.innerHTML = '';
                recentSmall.indices.forEach(i => {
                    const li = document.createElement('li');
                    const tp = rawData[i]?.totalPlayed;
                    if (tp !== undefined) li.textContent = `${tp}`;
                    listSmall.appendChild(li);
                });

                const recentBig = computeMinInSeries(seriesBig, startBig, (seriesBig?.length || 1) - 1);
                valBig.textContent = formatNum(recentBig.min);
                listBig.innerHTML = '';
                recentBig.indices.forEach(i => {
                    const li = document.createElement('li');
                    const tp = rawData[i]?.totalPlayed;
                    if (tp !== undefined) li.textContent = `${tp}`;
                    listBig.appendChild(li);
                });
            } catch (e) {
                console.warn('Failed to render low average scores', e);
            }
        }
        const recent = (baseArr, propName, length) => {
            let count = 0;
            return baseArr.map((row, i, arr) => {
                if (!length) return row[propName];

                const oi = i - length;
                if (!arr[oi] || !arr[oi][propName] || !row[propName]) {
                    return null;
                }
                return Math.round(((row[propName] * (i + 1)) - (arr[oi][propName] * (oi + 1))) / length * 100) / 100;
            })
        }

        // lookup data & helpers
        const roomColors = {
            default: '#666666',
            bronze: '#d98d14',
            silver: '#acb3bf',
            gold: '#f2c600',
            jade: '#00b359',
            throne: '#bf2640',
        };
        const roomColor = context => roomColors[slicedData.room[context.tick.value] || 'default'];

        // chart scaling
        const headerHeight = document.querySelector('.content-mahjong-stats .options').getBoundingClientRect().height;
        const h3Height = document.querySelector('.content-mahjong-stats h3').getBoundingClientRect().height + parseFloat(window.getComputedStyle(document.querySelector('.content-mahjong-stats h3')).marginBottom.slice(0, -2));
        document.documentElement.style.scrollPaddingTop = headerHeight + 'px';
        const targetHeight = window.innerHeight - headerHeight - h3Height;
        const targetWidth = document.querySelector('.content-mahjong-stats').getBoundingClientRect().width;
        const targetBaseRatio = targetWidth / targetHeight;
        console.log(targetBaseRatio)

        // statistical data
        const rawData = {{ statData|json_encode|raw }};
        let data;
        let offset;
        const parsedData = {};
        const slicedData = {};
        const parseData = (name, value) => {
            for (let field in rawData[0]) {
                if ('totalPlayed' === field || 'tstamp' === field) continue;
                if (name && ('id' === field || 'date' === field || 'room' === field || 'platform' === field || 'rank' === field || 'gameType' === field || 'exp' === field || 'maxHonba' === field || field.match(/^style/) || field.match(/^recentScore(?!_)/))) continue;
                parsedData[field + name] = recent(rawData, field, value);
            }
            parsedData['diff' + name] = parsedData['rateWin' + name].map((el, i) => {
                if (el === null) return null;
                return el - parsedData['rateDealIn' + name][i]
            })
            for (let place of [1, 2, 3, 4]) {
                parsedData['recentResult_rate' + name + '_' + place] = rater(rawData, 'recentResult', place, value);
            }
            parsedData['recentResult_avg' + name] = averager(rawData, 'recentResult', value);
            parsedData['recentScore_avg' + name] = averager(rawData, 'recentScore', value);
            parsedData['recentScore_rate' + name + '_negative'] = rater(rawData, 'recentScore', val => val < 0, value);
        }
        parseData('', 0);

        // charts
        const charts = [];
        updateCharts = () => {
            charts.forEach(el => {
                el.data.labels = slicedData.totalPlayed;
                el.data.datasets.forEach(dataset => {
                    let replacementValue = '';
                    if (dataset.label.match(/last \d+/)) {
                        const replacementType = dataset.parsedDataName.match(/(Big|Small)/);
                        if (replacementType) {
                            replacementValue = Alpine.store('graphs')['numRecent' + replacementType[0]];
                        }
                    }
                    if (replacementValue) {
                        dataset.label = dataset.label.replace(/last \d+/, 'last ' + replacementValue)
                    }
                    dataset.data = slicedData[dataset.parsedDataName];
                });
                el.update('none');
            });
            // UI now bound with Alpine templates; no imperative DOM updates needed
        }

        // reactivity
        Alpine.store('graphs', {
            numShow: 200,
            numRecentSmall: 25,
            numRecentBig: 100,
            init() {
                Alpine.effect(() => {
                    if (this.numShow > rawData.length) {
                        this.numShow = rawData.length;
                    }
                    offset = rawData.length - this.numShow;
                    data = rawData.slice(offset);
                    parsedData['totalPlayed'] = rawData.map(row => row.totalPlayed + (row.rank ? (' (' + row.rank + ')') : ''));
                    for (const key in parsedData) {
                        slicedData[key] = parsedData[key].slice(offset)
                    }
                    updateCharts();
                })
                Alpine.effect(() => {
                    parseData('Small', this.numRecentSmall);
                    for (const key in parsedData) {
                        slicedData[key] = parsedData[key].slice(offset)
                    }
                    updateCharts();
                })
                Alpine.effect(() => {
                    parseData('Big', this.numRecentBig);
                    for (const key in parsedData) {
                        slicedData[key] = parsedData[key].slice(offset)
                    }
                    updateCharts();
                })
            }
        })

        // chart initialization
        let lastContext = undefined;
        const myChart = new Chart(document.getElementById('chartjs'), {
            type: 'line',
            data: {
                labels: slicedData.totalPlayed,
                datasets: [
                    {
                        label: '{{ 'tl_patrickj_mjs.rateWin.0'|trans }}',
                        parsedDataName: 'rateWin',
                        data: slicedData.rateWin,
                        borderColor: '#2a0',
                        backgroundColor: 'transparent',
                    },
                    {
                        label: '{{ 'tl_patrickj_mjs.rateWin.0'|trans }} (last 100)',
                        parsedDataName: 'rateWinBig',
                        data: slicedData.rateWinBig,
                        borderWidth: 1,
                        borderColor: '#2a0',
                        backgroundColor: '#2a01',
                        fill: '-1',
                        segment: {
                            backgroundColor: context => {
                                return context.p1.raw >= 24 ? '#2a02' : context.p0.raw >= parseFloat(slicedData.rateWin[context.p0DataIndex]) && context.p1.raw >= parseFloat(slicedData.rateWin[context.p1DataIndex]) ? '#2a01' : context.p0.raw <= parseFloat(slicedData.rateWin[context.p0DataIndex]) && context.p1.raw <= parseFloat(slicedData.rateWin[context.p1DataIndex]) ? '#0001' : '#0001'
                            },
                        },
                    },
                    {
                        label: '{{ 'tl_patrickj_mjs.rateWin.0'|trans }} (last 25)',
                        parsedDataName: 'rateWinSmall',
                        data: slicedData.rateWinSmall,
                        borderWidth: 1,
                        borderColor: '#2a0',
                        backgroundColor: '#2a01',
                        fill: '-2',
                        segment: {
                            backgroundColor: context => {
                                return context.p1.raw >= 24 ? '#2a02' : context.p0.raw >= parseFloat(slicedData.rateWin[context.p0DataIndex]) && context.p1.raw >= parseFloat(slicedData.rateWin[context.p1DataIndex]) ? '#2a01' : context.p0.raw <= parseFloat(slicedData.rateWin[context.p0DataIndex]) && context.p1.raw <= parseFloat(slicedData.rateWin[context.p1DataIndex]) ? '#0001' : '#0001'
                            },
                        },
                        borderDash: [3, 2],
                    },
                    {
                        label: '{{ 'tl_patrickj_mjs.rateDealIn.0'|trans }}',
                        parsedDataName: 'rateDealIn',
                        data: slicedData.rateDealIn,
                        borderColor: '#d20',
                        backgroundColor: 'transparent',
                    },
                    {
                        label: '{{ 'tl_patrickj_mjs.rateDealIn.0'|trans }} (last 100)',
                        parsedDataName: 'rateDealInBig',
                        data: slicedData.rateDealInBig,
                        borderWidth: 1,
                        borderColor: '#d20',
                        backgroundColor: '#d202',
                        segment: {
                            backgroundColor: context => {
                                return context.p1.raw <= 14 ? '#d202' : context.p0.raw <= parseFloat(slicedData.rateDealIn[context.p0DataIndex]) && context.p1.raw <= parseFloat(slicedData.rateDealIn[context.p1DataIndex]) ? '#d201' : context.p0.raw <= parseFloat(slicedData.rateDealIn[context.p0DataIndex]) && context.p1.raw <= parseFloat(slicedData.rateDealIn[context.p1DataIndex]) ? '#0001' : '#0001'
                            },
                        },
                        fill: '-1',
                    },
                    {
                        label: '{{ 'tl_patrickj_mjs.rateDealIn.0'|trans }} (last 25)',
                        parsedDataName: 'rateDealInSmall',
                        data: slicedData.rateDealInSmall,
                        borderWidth: 1,
                        borderColor: '#d20',
                        backgroundColor: '#d201',
                        segment: {
                            backgroundColor: context => {
                                return context.p1.raw <= 14 ? '#d202' : context.p0.raw <= parseFloat(slicedData.rateDealIn[context.p0DataIndex]) && context.p1.raw <= parseFloat(slicedData.rateDealIn[context.p1DataIndex]) ? '#d201' : context.p0.raw <= parseFloat(slicedData.rateDealIn[context.p0DataIndex]) && context.p1.raw <= parseFloat(slicedData.rateDealIn[context.p1DataIndex]) ? '#0001' : '#0001'
                            },
                        },
                        fill: '-2',
                        borderDash: [3, 2],
                    },
                    {
                        label: 'Difference',
                        parsedDataName: 'diff',
                        data: slicedData.diff,
                        borderColor: '#fc0',
                        backgroundColor: 'transparent',
                    },
                    {
                        label: 'Difference (last 100)',
                        parsedDataName: 'diffBig',
                        data: slicedData.diffBig,
                        borderWidth: 1,
                        borderColor: '#fc0',
                        backgroundColor: '#fc01',
                        segment: {
                            backgroundColor: context => {
                                if (!context.p0.skip) {
                                    lastContext = context;
                                }
                                return context.p1.raw >= 10 ? '#fc02' : (!context.p0.skip && context.p0.raw || lastContext?.p0.raw) >= parseFloat(slicedData.diff[context.p0DataIndex]) && context.p1.raw >= parseFloat(slicedData.diff[context.p1DataIndex]) ? '#fc01' : (!context.p0.skip && context.p0.raw || lastContext?.p0.raw) <= parseFloat(slicedData.diff[context.p0DataIndex]) && context.p1.raw <= parseFloat(slicedData.diff[context.p1DataIndex]) ? '#0001' : '#0001'
                            },
                        },
                        fill: '-1',
                    },
                    {
                        label: 'Difference (last 25)',
                        parsedDataName: 'diffSmall',
                        data: slicedData.diffSmall,
                        borderWidth: 1,
                        borderColor: '#fc0',
                        backgroundColor: '#fc01',
                        segment: {
                            backgroundColor: context => {
                                if (!context.p0.skip) {
                                    lastContext = context;
                                }
                                return context.p1.raw >= 10 ? '#fc02' : (!context.p0.skip && context.p0.raw || lastContext?.p0.raw) >= parseFloat(slicedData.diff[context.p0DataIndex]) && context.p1.raw >= parseFloat(slicedData.diff[context.p1DataIndex]) ? '#fc01' : (!context.p0.skip && context.p0.raw || lastContext?.p0.raw) <= parseFloat(slicedData.diff[context.p0DataIndex]) && context.p1.raw <= parseFloat(slicedData.diff[context.p1DataIndex]) ? '#0001' : '#0001'
                            },
                        },
                        fill: '-2',
                        borderDash: [3, 2],
                    },
                ],
            },
            options: {
                aspectRatio: targetBaseRatio,
                spanGaps: true,
                pointRadius: 0,
                borderWidth: 2,
                scales: {
                    x: {
                        ticks: {
                            color: roomColor,
                        },
                    },
                    y: {
                        suggestedMin: 13,
                        suggestedMax: 26,
                        ticks: {
                            stepSize: 1,
                        },
                        grid: {
                            color: function(context) {
                                if (context.tick.value === 10) return '#fc0';
                                if (context.tick.value === 14) return '#e40';
                                if (context.tick.value === 24) return '#3c0';
                                return '#0001';
                            },
                        },
                        afterFit: function(axis) {axis.width = 60;},
                        afterBuildTicks: axis => {
                            if (!axis.ticks.find(el => el.value === 14)) axis.ticks.push({value: 14})
                            if (!axis.ticks.find(el => el.value === 24)) axis.ticks.push({value: 24})
                            if (!axis.ticks.find(el => el.value === 25)) axis.ticks.push({value: 25})
                        },
                    },
                },
            },
        });
        charts.push(myChart);
        const rankChart = new Chart(document.getElementById('chartjs-rank'), {
            type: 'line',
            data: {
                labels: slicedData.totalPlayed,
                datasets: [
                    {
                        // type: 'scatter',
                        label: '{{ 'tl_patrickj_mjs.recentResult.0'|trans }}',
                        parsedDataName: 'recentResult',
                        data: slicedData.recentResult,
                        yAxisID: 'rank',
                        showLine: false,
                        pointRadius: 2,
                        borderColor: '#000',
                        backgroundColor: '#000',
                        fill: 'none',
                    },
                    {
                        label: '{{ 'tl_patrickj_mjs.avgRank.0'|trans }}',
                        parsedDataName: 'avgRank',
                        data: slicedData.avgRank,
                        borderWidth: 1,
                        pointRadius: 0,
                        borderColor: '#000',
                        backgroundColor: '#0001',
                        segment: {
                            backgroundColor: context => context.p0.raw >= 2.5 && context.p1.raw >= 2.5 ? '#d201' : context.p0.raw <= 2.5 && context.p1.raw <= 2.5 ? '#2a01' : '#0001',
                        },
                    },
                    {
                        label: '{{ 'tl_patrickj_mjs.avgRank.0'|trans }} (last 100)',
                        parsedDataName: 'recentResult_avgBig',
                        data: slicedData.recentResult_avgBig,
                        borderWidth: 1,
                        pointRadius: 0,
                        borderColor: '#c8f',
                        backgroundColor: '#c8f1',
                        segment: {
                            backgroundColor: context => context.p0.raw >= 2.5 && context.p1.raw >= 2.5 ? '#d201' : context.p0.raw <= 2.5 && context.p1.raw <= 2.5 ? '#2a01' : '#0001',
                        },
                    },
                    {
                        label: '{{ 'tl_patrickj_mjs.avgRank.0'|trans }} (last 25)',
                        parsedDataName: 'recentResult_avgSmall',
                        data: slicedData.recentResult_avgSmall,
                        borderWidth: 1,
                        pointRadius: 0,
                        borderColor: '#e88',
                        borderDash: [3, 2],
                        backgroundColor: '#e881',
                        segment: {
                            backgroundColor: context => context.p0.raw >= 2.5 && context.p1.raw >= 2.5 ? '#d201' : context.p0.raw <= 2.5 && context.p1.raw <= 2.5 ? '#2a01' : '#0001',
                        },
                    },
                ],
            },
            options: {
                aspectRatio: targetBaseRatio,
                fill: {value: 2.5},
                spanGaps: true,
                scales: {
                    x: {
                        ticks: {
                            color: roomColor,
                        },
                    },
                    y: {
                        reverse: true,
                        grid: {
                            color: context => {
                                if (context.tick.value === 2.5) return '#aaa';
                                return '#0001';
                            }
                        },
                        afterDataLimits: (context) => {
                            const offset = Math.max(Math.abs(2.5 - context.min), Math.abs(2.5 - context.max));
                            context.min = 2.5 - offset;
                            context.max = 2.5 + offset;
                        },
                        afterBuildTicks: axis => {
                            if (!axis.ticks.find(el => el.value === 2.5)) axis.ticks.push({value: 2.5})
                        },
                        afterFit: function(axis) {axis.width = 35;},
                    },
                    rank: {
                        axis: 'y',
                        grid: {
                            drawOnChartArea: false,
                        },
                        min: 1,
                        max: 4,
                        reverse: true,
                        ticks: {
                            count: 4,
                        },
                        afterFit: function(axis) {axis.width = 25;},
                    },
                },
            },
        });
        charts.push(rankChart);
        const pointsChart = new Chart(document.getElementById('chartjs-points'), {
            type: 'bar',
            data: {
                labels: slicedData.totalPlayed,
                datasets: [
                    {
                        label: '{{ 'tl_patrickj_mjs.recentScoreFourth.0'|trans }}',
                        parsedDataName: 'recentScoreFourth',
                        data: slicedData.recentScoreFourth,
                        borderWidth: 1,
                        borderColor: '#d20',
                        backgroundColor: '#d20',
                    },
                    {
                        label: '{{ 'tl_patrickj_mjs.recentScoreThird.0'|trans }}',
                        parsedDataName: 'recentScoreThird',
                        data: slicedData.recentScoreThird,
                        borderWidth: 1,
                        borderColor: '#f80',
                        backgroundColor: '#f80',
                    },
                    {
                        label: '{{ 'tl_patrickj_mjs.recentScoreSecond.0'|trans }}',
                        parsedDataName: 'recentScoreSecond',
                        data: slicedData.recentScoreSecond,
                        borderWidth: 1,
                        borderColor: '#dd0',
                        backgroundColor: '#dd0',
                    },
                    {
                        label: '{{ 'tl_patrickj_mjs.recentScoreFirst.0'|trans }}',
                        parsedDataName: 'recentScoreFirst',
                        data: slicedData.recentScoreFirst,
                        borderWidth: 1,
                        borderColor: '#2a0',
                        backgroundColor: '#2a0',
                    },
                    {
                        type: 'line',
                        label: '{{ 'tl_patrickj_mjs.recentScore.0'|trans }}',
                        parsedDataName: 'recentScore',
                        data: slicedData.recentScore,
                        borderWidth: 1,
                        pointRadius: 2,
                        borderColor: '#000',
                        backgroundColor: '#fff',
                        order: -1,
                        fill: false,
                        showLine: false,
                    },
                    {
                        type: 'line',
                        label: '{{ 'tl_patrickj_mjs.avgScore.0'|trans }}',
                        parsedDataName: 'recentScore_avg',
                        data: slicedData.recentScore_avg,
                        borderWidth: 1,
                        pointRadius: 0,
                        borderColor: '#000',
                        backgroundColor: 'transparent',
                        order: -1,
                        fill: false,
                    },
                    {
                        type: 'line',
                        label: '{{ 'tl_patrickj_mjs.avgScore.0'|trans }} (last 100)',
                        parsedDataName: 'recentScore_avgBig',
                        data: slicedData.recentScore_avgBig,
                        borderWidth: 1,
                        pointRadius: 0,
                        borderColor: '#fff',
                        backgroundColor: 'transparent',
                        order: -2,
                        fill: false,
                    },
                ],
            },
            options: {
                aspectRatio: targetBaseRatio,
                categoryPercentage: 1,
                fill: true,
                pointBorderColor: '#666',
                spanGaps: true,
                scales: {
                    x: {
                        ticks: {
                            color: roomColor,
                        },
                        stacked: true,
                    },
                    y: {
                        ticks: {
                            stepSize: 10000,
                        },
                        grid: {
                            color: context => {
                                if (context.tick.value === 25000) return '#0005';
                                return '#0001';
                            }
                        },
                        afterBuildTicks: axis => {
                            if (!axis.ticks.find(el => el.value === 25000)) axis.ticks.push({value: 25000})
                        },
                        afterFit: function(axis) {axis.width = 60;},
                    },
                },
            },
        });
        charts.push(pointsChart);
        const placesChart = new Chart(document.getElementById('chartjs-places'), {
            type: 'line',
            data: {
                labels: slicedData.totalPlayed,
                datasets: [
                    {
                        label: '{{ 'tl_patrickj_mjs.rateFourth.0'|trans }}',
                        parsedDataName: 'rateFourth',
                        data: slicedData.rateFourth,
                        borderWidth: 1,
                        borderColor: '#d20',
                        backgroundColor: '#d20',
                        fill: 'start',
                    },
                    {
                        label: '{{ 'tl_patrickj_mjs.rateThird.0'|trans }}',
                        parsedDataName: 'rateThird',
                        data: slicedData.rateThird,
                        borderWidth: 1,
                        borderColor: '#f80',
                        backgroundColor: '#f80',
                    },
                    {
                        label: '{{ 'tl_patrickj_mjs.rateSecond.0'|trans }}',
                        parsedDataName: 'rateSecond',
                        data: slicedData.rateSecond,
                        borderWidth: 1,
                        borderColor: '#dd0',
                        backgroundColor: '#dd0',
                    },
                    {
                        label: '{{ 'tl_patrickj_mjs.rateFirst.0'|trans }}',
                        parsedDataName: 'rateFirst',
                        data: slicedData.rateFirst,
                        borderWidth: 1,
                        borderColor: '#2a0',
                        backgroundColor: '#2a0',
                    },
                    {
                        label: '{{ 'tl_patrickj_mjs.rateNegative.0'|trans }}',
                        parsedDataName: 'rateNegative',
                        data: slicedData.rateNegative,
                        borderWidth: 1,
                        borderColor: '#0004',
                        backgroundColor: '#0004',
                        fill: 'start',
                        stack: 'unstacked',
                        order: -5,
                    },
                    {
                        label: '{{ 'tl_patrickj_mjs.rateFourth.0'|trans }} (last 100)',
                        parsedDataName: 'recentResult_rateBig_4',
                        data: slicedData.recentResult_rateBig_4,
                        borderWidth: 1,
                        borderColor: '#000',
                        backgroundColor: '#b204',
                        stack: 'lastBig',
                        order: -10,
                    },
                    {
                        label: '{{ 'tl_patrickj_mjs.rateThird.0'|trans }} (last 100)',
                        parsedDataName: 'recentResult_rateBig_3',
                        data: slicedData.recentResult_rateBig_3,
                        borderWidth: 1,
                        borderColor: '#000',
                        backgroundColor: '#f804',
                        stack: 'lastBig',
                        order: -10,
                    },
                    {
                        label: '{{ 'tl_patrickj_mjs.rateSecond.0'|trans }} (last 100)',
                        parsedDataName: 'recentResult_rateBig_2',
                        data: slicedData.recentResult_rateBig_2,
                        borderWidth: 1,
                        borderColor: '#000',
                        backgroundColor: '#dd04',
                        stack: 'lastBig',
                        order: -10,
                    },
                    {
                        label: '{{ 'tl_patrickj_mjs.rateFirst.0'|trans }} (last 100)',
                        parsedDataName: 'recentResult_rateBig_1',
                        data: slicedData.recentResult_rateBig_1,
                        borderWidth: 1,
                        borderColor: '#000',
                        backgroundColor: '#2804',
                        stack: 'lastBig',
                        order: -10,
                    },
                    {
                        label: '{{ 'tl_patrickj_mjs.rateNegative.0'|trans }} (last 100)',
                        parsedDataName: 'recentScore_rateBig_negative',
                        data: slicedData.recentScore_rateBig_negative,
                        borderWidth: 1,
                        borderColor: '#000',
                        backgroundColor: '#0002',
                        fill: 'start',
                        stack: 'lastBigunstacked',
                        order: -15,
                    },
                    {
                        label: '{{ 'tl_patrickj_mjs.rateFourth.0'|trans }} (last 25)',
                        parsedDataName: 'recentResult_rateSmall_4',
                        data: slicedData.recentResult_rateSmall_4,
                        borderWidth: 1,
                        borderColor: '#fff',
                        borderDash: [3, 2],
                        backgroundColor: 'transparent',
                        fill: 'start',
                        stack: 'lastSmall',
                        order: -20,
                    },
                    {
                        label: '{{ 'tl_patrickj_mjs.rateThird.0'|trans }} (last 25)',
                        parsedDataName: 'recentResult_rateSmall_3',
                        data: slicedData.recentResult_rateSmall_3,
                        borderWidth: 1,
                        borderColor: '#fff',
                        borderDash: [3, 2],
                        backgroundColor: 'transparent',
                        stack: 'lastSmall',
                        order: -20,
                    },
                    {
                        label: '{{ 'tl_patrickj_mjs.rateSecond.0'|trans }} (last 25)',
                        parsedDataName: 'recentResult_rateSmall_2',
                        data: slicedData.recentResult_rateSmall_2,
                        borderWidth: 1,
                        borderColor: '#fff',
                        borderDash: [3, 2],
                        backgroundColor: 'transparent',
                        stack: 'lastSmall',
                        order: -20,
                    },
                    {
                        label: '{{ 'tl_patrickj_mjs.rateFirst.0'|trans }} (last 25)',
                        parsedDataName: 'recentResult_rateSmall_1',
                        data: slicedData.recentResult_rateSmall_1,
                        borderWidth: 1,
                        borderColor: '#fff',
                        borderDash: [3, 2],
                        backgroundColor: 'transparent',
                        stack: 'lastSmall',
                        order: -20,
                    },
                    {
                        label: '{{ 'tl_patrickj_mjs.rateNegative.0'|trans }} (last 25)',
                        parsedDataName: 'recentScore_rateSmall_negative',
                        data: slicedData.recentScore_rateSmall_negative,
                        borderWidth: 1,
                        borderColor: '#fff',
                        borderDash: [3, 2],
                        backgroundColor: 'transparent',
                        stack: 'lastSmall_unstacked',
                        order: -25,
                    },
                ],
            },
            options: {
                aspectRatio: targetBaseRatio,
                fill: '-1',
                spanGaps: true,
                pointRadius: 0,
                scales: {
                    x: {
                        ticks: {
                            color: roomColor,
                        },
                    },
                    y: {
                        stacked: true,
                        min: 0,
                        max: 100,
                        ticks: {
                            count: 5,
                        },
                        grid: {
                            z: 1,
                        },
                        afterFit: function(axis) {axis.width = 60;},
                    },
                },
            },
        });
        charts.push(placesChart);
        const styleChart = new Chart(document.getElementById('chartjs-style'), {
            type: 'line',
            data: {
                labels: slicedData.totalPlayed,
                datasets: [
                    {
                        label: '{{ 'tl_patrickj_mjs.styleAtk.0'|trans }}',
                        parsedDataName: 'styleAtk',
                        data: slicedData.styleAtk,
                        borderWidth: 1,
                        backgroundColor: '#e63a89',
                    },
                    {
                        label: '{{ 'tl_patrickj_mjs.styleDef.0'|trans }}',
                        parsedDataName: 'styleDef',
                        data: slicedData.styleDef,
                        borderWidth: 1,
                        backgroundColor: '#71e39c',
                    },
                    {
                        label: '{{ 'tl_patrickj_mjs.styleSpd.0'|trans }}',
                        parsedDataName: 'styleSpd',
                        data: slicedData.styleSpd,
                        borderWidth: 1,
                        backgroundColor: '#65ccd3',
                    },
                    {
                        label: '{{ 'tl_patrickj_mjs.styleLuk.0'|trans }}',
                        parsedDataName: 'styleLuk',
                        data: slicedData.styleLuk,
                        borderWidth: 1,
                        backgroundColor: '#ae8152',
                    },
                ],
            },
            options: {
                aspectRatio: targetBaseRatio,
                fill: true,
                spanGaps: true,
                pointRadius: 0,
                scales: {
                    x: {
                        ticks: {
                            color: roomColor,
                        },
                    },
                    y: {
                        stacked: true,
                        min: 0,
                        afterFit: function(axis) {axis.width = 60;},
                    },
                },
            },
        });
        charts.push(styleChart);
        const megaChart = new Chart(document.getElementById('chartjs-mega'), {
            type: 'line',
            data: {
                labels: slicedData.totalPlayed,
                datasets: [
                    {
                        label: '{{ 'tl_patrickj_mjs.avgScore.0'|trans }}',
                        parsedDataName: 'avgScore',
                        data: slicedData.avgScore,
                        yAxisID: 'score',
                        borderColor: '#d608',
                        pointRadius: 2,
                        borderWidth: 1,
                        cubicInterpolationMode: 'monotone',
                    },
                    {
                        label: '{{ 'tl_patrickj_mjs.maxHonba.0'|trans }}',
                        parsedDataName: 'maxHonba',
                        data: slicedData.maxHonba,
                        stepped: true,
                        borderColor: '#da0',
                    },
                    {
                        label: '{{ 'tl_patrickj_mjs.avgTurns.0'|trans }}',
                        parsedDataName: 'avgTurns',
                        data: slicedData.avgTurns,
                        borderColor: '#ed0',
                    },
                    {
                        label: '{{ 'tl_patrickj_mjs.avgTurns.0'|trans }} (last 100)',
                        parsedDataName: 'avgTurnsBig',
                        data: slicedData.avgTurnsBig,
                        borderWidth: 1,
                        borderColor: '#ed0',
                        fill: '-1',
                        backgroundColor: '#ed01'
                    },
                    {
                        label: '{{ 'tl_patrickj_mjs.rateTsumo.0'|trans }}',
                        parsedDataName: 'rateTsumo',
                        data: slicedData.rateTsumo,
                        borderColor: '#a4d',
                    },
                    {
                        label: '{{ 'tl_patrickj_mjs.rateTsumo.0'|trans }} (last 100)',
                        parsedDataName: 'rateTsumoBig',
                        data: slicedData.rateTsumoBig,
                        borderWidth: 1,
                        borderColor: '#a4d',
                        fill: '-1',
                        backgroundColor: '#a4d1'
                    },
                    {
                        label: '{{ 'tl_patrickj_mjs.rateCall.0'|trans }}',
                        parsedDataName: 'rateCall',
                        data: slicedData.rateCall,
                        borderColor: '#0d2',
                    },
                    {
                        label: '{{ 'tl_patrickj_mjs.rateCall.0'|trans }} (last 100)',
                        parsedDataName: 'rateCallBig',
                        data: slicedData.rateCallBig,
                        borderWidth: 1,
                        borderColor: '#0d2',
                        fill: '-1',
                        backgroundColor: '#0d21'
                    },
                    {
                        label: '{{ 'tl_patrickj_mjs.rateRiichi.0'|trans }}',
                        parsedDataName: 'rateRiichi',
                        data: slicedData.rateRiichi,
                        borderColor: '#7bd',
                    },
                    {
                        label: '{{ 'tl_patrickj_mjs.rateRiichi.0'|trans }} (last 100)',
                        parsedDataName: 'rateRiichiBig',
                        data: slicedData.rateRiichiBig,
                        borderWidth: 1,
                        borderColor: '#7bd',
                        fill: '-1',
                        backgroundColor: '#7bd1'
                    },
                    {
                        label: '{{ 'tl_patrickj_mjs.exp.0'|trans }}',
                        parsedDataName: 'exp',
                        data: slicedData.exp,
                        yAxisID: 'exp',
                        borderColor: '#8888',
                        pointRadius: 2,
                        borderWidth: 1,
                        cubicInterpolationMode: 'monotone',
                        segment: {
                            borderColor: context => {
                                // Extract rank from labels
                                const rankRegex = /\((.*?)\)/;
                                const p0Label = slicedData.totalPlayed[context.p0DataIndex];
                                const p1Label = slicedData.totalPlayed[context.p1DataIndex];

                                const p0Match = p0Label && p0Label.match(rankRegex);
                                const p1Match = p1Label && p1Label.match(rankRegex);

                                const p0Rank = p0Match ? p0Match[1] : null;
                                const p1Rank = p1Match ? p1Match[1] : null;

                                // If ranks are different, color the segment
                                if (p0Rank && p1Rank && p0Rank !== p1Rank) {
                                    // Get rank levels for comparison
                                    const rankOrder = {
                                        'novice1': 1, 'novice2': 2, 'novice3': 3,
                                        'adept1': 4, 'adept2': 5, 'adept3': 6,
                                        'expert1': 7, 'expert2': 8, 'expert3': 9,
                                        'master1': 10, 'master2': 11, 'master3': 12,
                                        'saint1': 13, 'saint2': 14, 'saint3': 15
                                    };

                                    const p0Level = rankOrder[p0Rank] || 0;
                                    const p1Level = rankOrder[p1Rank] || 0;

                                    // Green for rank up, red for rank down
                                    return p1Level > p0Level ? '#2a08' : '#d208';
                                }

                                return '#8888';
                            }
                        },
                    },
                ],
            },
            options: {
                aspectRatio: targetBaseRatio,
                backgroundColor: 'transparent',
                pointRadius: 0,
                borderWidth: 2,
                spanGaps: true,
                scales: {
                    x: {
                        ticks: {
                            color: roomColor,
                        },
                    },
                    y: {
                    },
                    score: {
                        axis: 'y',
                        ticks: {
                            stepSize: 100,
                        },
                        afterBuildTicks: axis => {
                            if (!axis.ticks.find(el => el.value === 6000)) axis.ticks.push({value: 6000})
                        },
                    },
                    exp: {
                        axis: 'y',
                    },
                },
            },
        });
        charts.push(megaChart);

        // Render longest no-1st streaks info (overall)
        try {
            const streaks = computeStreaks(rawData, row => parseInt(row.recentResult) !== 1);
            const longestValueEl = document.getElementById('streakLongestValue');
            const listEl = document.getElementById('streakLongestRanges');
            if (longestValueEl && listEl) {
                longestValueEl.textContent = streaks.max + ' ' + '{{ 'tl_patrickj_mjs.games.0'|trans }}';
                listEl.innerHTML = '';
                // Show top 3 unique lengths (including the longest) with their ranges
                topStreakGroups(streaks.segments, 3).forEach(group => {
                    const li = document.createElement('li');
                    const title = document.createElement('div');
                    title.innerHTML = `<strong>${group.len} {{ 'tl_patrickj_mjs.games.0'|trans }}</strong>`;
                    li.appendChild(title);
                    const sub = document.createElement('ul');
                    sub.style.margin = '.25rem 0 0 .75rem';
                    group.ranges.forEach(s => {
                        const r = document.createElement('li');
                        const start = rawData[s.start]?.totalPlayed;
                        const end = rawData[s.end]?.totalPlayed;
                        if (start !== undefined && end !== undefined) {
                            r.textContent = `${start} - ${end}`;
                            sub.appendChild(r);
                        }
                    });
                    li.appendChild(sub);
                    listEl.appendChild(li);
                });
            }
        } catch (e) {
            console.warn('Failed to compute no-1st streaks', e);
        }

        // Render longest no-4th streaks info (overall)
        try {
            const streaks = computeStreaks(rawData, row => parseInt(row.recentResult) !== 4);
            const valueEl = document.getElementById('streakNoFourthValue');
            const listEl = document.getElementById('streakNoFourthRanges');
            if (valueEl && listEl) {
                valueEl.textContent = streaks.max + ' ' + '{{ 'tl_patrickj_mjs.games.0'|trans }}';
                listEl.innerHTML = '';
                // Show top 3 unique lengths (including the longest) with their ranges
                topStreakGroups(streaks.segments, 5).forEach(group => {
                    const li = document.createElement('li');
                    const title = document.createElement('div');
                    title.innerHTML = `<strong>${group.len} {{ 'tl_patrickj_mjs.games.0'|trans }}</strong>`;
                    li.appendChild(title);
                    const sub = document.createElement('ul');
                    sub.style.margin = '.25rem 0 0 .75rem';
                    group.ranges.forEach(s => {
                        const r = document.createElement('li');
                        const start = rawData[s.start]?.totalPlayed;
                        const end = rawData[s.end]?.totalPlayed;
                        if (start !== undefined && end !== undefined) {
                            r.textContent = `${start} - ${end}`;
                            sub.appendChild(r);
                        }
                    });
                    li.appendChild(sub);
                    listEl.appendChild(li);
                });
            }
        } catch (e) {
            console.warn('Failed to compute no-4th streaks', e);
        }

        // Render consecutive place streaks (1st4th)
        try {
            const container = document.getElementById('streakConsecutiveList');
            if (container) {
                container.innerHTML = '';
                const labels = {
                    1: '{{ 'tl_patrickj_mjs.rateFirst.0'|trans }}',
                    2: '{{ 'tl_patrickj_mjs.rateSecond.0'|trans }}',
                    3: '{{ 'tl_patrickj_mjs.rateThird.0'|trans }}',
                    4: '{{ 'tl_patrickj_mjs.rateFourth.0'|trans }}',
                };
                for (let p = 1; p <= 4; p++) {
                    const streaks = computeStreaks(rawData, row => parseInt(row.recentResult) === p);
                    const li = document.createElement('li');
                    const title = document.createElement('div');
                    title.innerHTML = `<strong>${labels[p]}:</strong> ${streaks.max} {{ 'tl_patrickj_mjs.games.0'|trans }}`;
                    li.appendChild(title);
                    const sub = document.createElement('ul');
                    sub.style.margin = '.25rem 0 0 .75rem';
                    streaks.longest.forEach(s => {
                        const r = document.createElement('li');
                        const start = rawData[s.start]?.totalPlayed;
                        const end = rawData[s.end]?.totalPlayed;
                        if (start !== undefined && end !== undefined) {
                            r.textContent = `${start} - ${end}`;
                            sub.appendChild(r);
                        }
                    });
                    li.appendChild(sub);
                    container.appendChild(li);
                }
            }
        } catch (e) {
            console.warn('Failed to compute consecutive place streaks', e);
        }
    });

        document.querySelectorAll('[id^="anchor"]').forEach(el => el.addEventListener('click', e => window.location.hash = e.target.id.replace('anchor', 'section')))
    </script>
{% endblock %}
